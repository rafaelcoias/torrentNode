public class App {
    public static void main(String[] args) {
        // Guardar em variaveis os argumentos fornecidos, ou usar valores padrão
        String ipAddress = args.length > 0 ? args[0] : "127.0.0.1";
        int port = args.length > 1 ? Integer.parseInt(args[1]) : 8080;
        String fileDirectory = args.length > 2 ? args[2] : System.getProperty("user.dir");

        System.out.println("A inicializar novo nó:");
        System.out.println("=> Endereço IP: " + ipAddress);
        System.out.println("=> Porta: " + port);
        System.out.println("=> Pasta de ficheiros: " + fileDirectory);

        // Criar um novo nó
        new IscTorrentNode(ipAddress, port, fileDirectory);
    }
}
import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

public class ClientHandler implements Runnable {
    private Socket clientSocket;
    private String fileDirectory;
    private IscTorrentNode node;

    public ClientHandler(Socket clientSocket, String fileDirectory, IscTorrentNode node) {
        this.clientSocket = clientSocket;
        this.fileDirectory = fileDirectory;
        this.node = node;
    }

    // Funções públicas

    @Override
    public void run() {
        try {
            ObjectOutputStream out = new ObjectOutputStream(clientSocket.getOutputStream());
            out.flush();
            ObjectInputStream in = new ObjectInputStream(clientSocket.getInputStream());

            System.out.println("Object streams criados para o cliente: " + clientSocket.getLocalSocketAddress());

            // Loop para lidar com mensagens do cliente, fica aberto até a conexão ser
            // fechada
            while (true) {
                Object message = in.readObject();

                // Se a mensagem for uma string e começar com "CONNECT", é um pedido de conexão
                if (message instanceof String && ((String) message).startsWith("CONNECT")) {
                    String neighbor = ((String) message).split(" ")[1];
                    // Adiciona o vizinho à lista de vizinhos
                    System.out.println("Novo vizinho adicionado: " + neighbor);
                    node.addNeighbor(neighbor);
                    out.writeObject("OK CONNECTED");
                    out.flush();
                    continue;
                }

                // Se a mensagem for uma instância de SearchRequest, é um pedido de pesquisa
                if (message instanceof SearchRequest) {
                    handleSearchRequest((SearchRequest) message, out);
                } else if (message instanceof FileRequest) {
                    // Se a mensagem for uma instância de FileRequest, é um pedido de download
                    handleFileRequest((FileRequest) message, out);
                } else {
                    System.err.println("Mensagem inválida recebida: " + message);
                }
            }
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("Erro de comunicação com o cliente.");
        } finally {
            try {
                clientSocket.close();
                System.out.println("Conexão fechada com o cliente: " + clientSocket.getLocalSocketAddress());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    // Funções privadas

    // Funções de pesquisa

    private void handleSearchRequest(SearchRequest request, ObjectOutputStream out) throws IOException {
        String searchTerm = request.getSearchTerm();
        System.out.println("Termo de pesquisa recebido: " + searchTerm);

        // Procurar ficheiros locais
        List<String> foundFiles = searchLocalFiles(searchTerm);
        System.out.println("Ficheiros locais encontrados: " + foundFiles);

        // Propagar o pedido de pesquisa para os vizinhos
        List<String> neighborFiles = searchInNeighbors(searchTerm);
        System.out.println("Ficheiros encontrados nos vizinhos: " + neighborFiles);

        // Combinar os resultados locais e os dos vizinhos
        foundFiles.addAll(neighborFiles);

        // Enviar a resposta de volta para o cliente
        SearchResponse response = new SearchResponse(foundFiles);
        out.writeObject(response);
        out.flush();
        System.out.println("Resposta de pesquisa enviada: " + foundFiles);
    }

    private List<String> searchLocalFiles(String searchTerm) {
        List<String> filesFound = new ArrayList<>();
        File directory = new File(fileDirectory);

        if (!directory.exists() || !directory.isDirectory()) {
            System.err.println("Diretório não encontrado ou inválido: " + directory.getAbsolutePath());
            return filesFound;
        }

        File[] allFiles = directory.listFiles();
        if (allFiles != null) {
            System.out.println("Ficheiros no diretório fornecido:");
            for (File file : allFiles)
                System.out.println(" - " + file.getName());
        } else {
            System.out.println("Nenhum ficheiro encontrado no diretório fornecido.");
        }

        for (File file : allFiles) {
            if (file.isFile() && file.getName().contains(searchTerm)) {
                filesFound.add(file.getName());
            }
        }

        System.out.println("Ficheiros encontrados com o termo '" + searchTerm + "': " + filesFound);
        return filesFound;
    }

    private List<String> searchInNeighbors(String searchTerm) {
        System.out.println("Iniciar a pesquisa nos vizinhos. Lista de vizinhos atual: " + node.getConnectedNodes());
        List<String> allFiles = new ArrayList<>();

        for (String neighbor : node.getConnectedNodes()) {
            System.out.println("Tentar conectar ao vizinho: " + neighbor);
            try {
                String[] parts = neighbor.split(":");
                String ip = parts[0];
                int port = Integer.parseInt(parts[1]);

                try (Socket socket = new Socket(ip, port);
                        ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
                        ObjectInputStream in = new ObjectInputStream(socket.getInputStream())) {

                    out.writeObject(new SearchRequest(searchTerm));
                    out.flush();
                    System.out.println("Pedido de pesquisa enviado para vizinho: " + neighbor);

                    Object response = in.readObject();
                    if (response instanceof SearchResponse) {
                        SearchResponse searchResponse = (SearchResponse) response;
                        allFiles.addAll(searchResponse.getFileNames());
                        System.out.println(
                                "Resposta recebida do vizinho " + neighbor + ": " + searchResponse.getFileNames());
                    }
                }
            } catch (Exception e) {
                System.err.println("Erro ao comunicar com o vizinho " + neighbor + ": " + e.getMessage());
            }
        }
        return allFiles;
    }

    // Funções de download

    private void handleFileRequest(FileRequest request, ObjectOutputStream out) throws IOException {
        String fileName = request.getFileName();
        int dataIndex = request.getDataIndex();
    
        File file = new File(fileDirectory, fileName); // Usa o diretório base configurado para localizar o ficheiro
        System.out.println("Caminho do ficheiro solicitado: " + file.getAbsolutePath());
        if (file.exists() && file.isFile()) {
            System.out.println("Pedido de bloco recebido para " + fileName + " (índice: " + dataIndex + ")");
            byte[] fileData = readData(file, dataIndex);
    
            if (fileData.length == 0) {
                System.out.println("Fim do ficheiro detectado no servidor para " + fileName);
            }
    
            FileResponse response = new FileResponse(fileData, dataIndex);
            out.writeObject(response);
            out.flush();
            System.out.println("Bloco enviado para " + fileName + " (índice: " + dataIndex + ")");
        } else {
            System.err.println("Ficheiro não encontrado ou inválido: " + file.getAbsolutePath());
            throw new IOException("Ficheiro não encontrado ou inválido: " + file.getName());
        }
    }
    
    private byte[] readData(File file, int dataIndex) throws IOException {
        int dataSize = 10240; // Tamanho padrão de bloco
        byte[] buffer = new byte[dataSize];
    
        try (FileInputStream fileInputStream = new FileInputStream(file)) {
            long skippedBytes = fileInputStream.skip((long) dataIndex * dataSize);
            System.out.println("Bytes saltados: " + skippedBytes);
    
            int bytesRead = fileInputStream.read(buffer);
            System.out.println("Bytes lidos: " + bytesRead);
    
            if (bytesRead == -1) {
                System.out.println("Fim do ficheiro atingido.");
                return new byte[0];
            }
    
            // Caso o último bloco seja menor que o tamanho padrão
            if (bytesRead < dataSize) {
                byte[] lastData = new byte[bytesRead];
                System.arraycopy(buffer, 0, lastData, 0, bytesRead);
                return lastData;
            }
        }
        return buffer;
    }
    

}
import java.io.Serializable;

public class FileRequest implements Serializable {
    private static final long serialVersionUID = 1L;
    private String fileName;
    private int dataIndex;

    public FileRequest(String fileName, int dataIndex) {
        this.fileName = fileName;
        this.dataIndex = dataIndex;
    }

    public String getFileName() {
        return fileName;
    }

    public int getDataIndex() {
        return dataIndex;
    }
}
import java.io.Serializable;

public class FileResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private byte[] fileData;
    private int dataIndex;

    public FileResponse(byte[] fileData, int dataIndex) {
        this.fileData = fileData;
        this.dataIndex = dataIndex;
    }

    public byte[] getFileData() {
        return fileData;
    }

    public int getDataIndex() {
        return dataIndex;
    }
}
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

public class IscTorrentNode {

    private String ipAddress;
    private int port;
    private String fileDirectory;
    private List<String> connectedNodes;

    public IscTorrentNode(String ipAddress, int port, String fileDirectory) {
        this.ipAddress = ipAddress;
        this.port = port;
        this.fileDirectory = fileDirectory;
        this.connectedNodes = new ArrayList<>();

        // Inicializa a interface gráfica deste nó
        initializeInterface();

        // Inicializa o servidor deste nó
        NodeServer server = new NodeServer(port, fileDirectory, this);
        server.startServer();
    }

    private void initializeInterface() {
        // Configuração incial
        JFrame frame = new JFrame("Sistema de Partilha de Ficheiros");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(600, 400);
        frame.setLayout(new BorderLayout());

        // Informações do nó
        JPanel infoPanel = new JPanel();
        infoPanel.setLayout(new FlowLayout(FlowLayout.LEFT));
        JLabel infoLabel = new JLabel("IP: " + ipAddress + " | Porta: " + port + " | Pasta: " + fileDirectory);
        infoPanel.add(infoLabel);
        frame.add(infoPanel, BorderLayout.NORTH);

        // Painel de pesquisa e resultados
        JPanel centerPanel = new JPanel();
        centerPanel.setLayout(new BorderLayout());

        // Pesquisa de ficheiros
        JPanel searchPanel = new JPanel();
        searchPanel.setLayout(new FlowLayout());
        JTextField searchField = new JTextField(20);
        JButton searchButton = new JButton("Procurar");
        searchPanel.add(new JLabel("Texto a procurar:"));
        searchPanel.add(searchField);
        searchPanel.add(searchButton);

        // Resultados da pesquisa
        DefaultListModel<String> searchResults = new DefaultListModel<>();
        JList<String> searchResultsList = new JList<>(searchResults);
        JScrollPane scrollPane = new JScrollPane(searchResultsList);

        // Adiciona o painel de pesquisa e a lista de resultados ao painel central
        centerPanel.add(searchPanel, BorderLayout.NORTH);
        centerPanel.add(scrollPane, BorderLayout.CENTER);

        frame.add(centerPanel, BorderLayout.CENTER);

        // Ações
        JPanel actionPanel = new JPanel();
        actionPanel.setLayout(new FlowLayout());
        JButton connectButton = new JButton("Ligar a Nó");
        JButton downloadButton = new JButton("Descarregar");
        actionPanel.add(downloadButton);
        actionPanel.add(connectButton);
        frame.add(actionPanel, BorderLayout.SOUTH);

        // Ações dos botões
        searchButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                String searchTerm = searchField.getText().trim();
                if (searchTerm.isEmpty()) {
                    JOptionPane.showMessageDialog(frame, "Por favor, insira um termo de pesquisa válido.");
                    return;
                }
                searchFiles(searchTerm, searchResults);
            }
        });

        connectButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                connectNode();
            }
        });

        downloadButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                String selectedFile = searchResultsList.getSelectedValue();
                if (selectedFile == null) {
                    JOptionPane.showMessageDialog(frame, "Por favor, selecione um ficheiro para descarregar.");
                    return;
                }
                downloadFile(selectedFile);
            }
        });

        // Mostrar a interface gráfica após a configuração estar completa
        frame.setVisible(true);
    }

    // Nova thread para enviar o pedido de pesquisa e esperar pela resposta dos
    // clientes
    private void searchFiles(String searchTerm, DefaultListModel<String> searchResults) {
        new Thread(() -> {
            try (Socket socket = new Socket(ipAddress, port);
                    ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
                    ObjectInputStream in = new ObjectInputStream(socket.getInputStream())) {

                // Enviar o pedido de pesquisa
                out.writeObject(new SearchRequest(searchTerm));
                out.flush();
                System.out.println("Pedido de pesquisa enviado: " + searchTerm);

                // Receber a resposta
                Object response = in.readObject();
                if (response instanceof SearchResponse) {
                    SearchResponse searchResponse = (SearchResponse) response;
                    List<String> fileNames = searchResponse.getFileNames();

                    // Atualizar os resultados na interface
                    SwingUtilities.invokeLater(() -> {
                        searchResults.clear();
                        for (String fileName : fileNames) {
                            searchResults.addElement(fileName);
                        }
                    });
                    System.out.println("Resposta de pesquisa recebida: " + fileNames);
                } else {
                    System.err.println("Resposta inesperada do servidor: " + response.getClass().getName());
                }
            } catch (Exception e) {
                System.err.println("Erro na pesquisa: " + e.getMessage());
            }
        }).start();
    }

    public synchronized void addNeighbor(String neighbor) {
        if (!connectedNodes.contains(neighbor)) {
            connectedNodes.add(neighbor);
            System.out.println("Vizinho adicionado: " + neighbor);
            System.out.println("Lista de vizinhos atualizada: " + connectedNodes);
        } else {
            System.out.println("Vizinho já existe: " + neighbor);
        }
    }
    

    // Método para obter a lista de vizinhos
    public synchronized List<String> getConnectedNodes() {
        return new ArrayList<>(connectedNodes);
    }

    // Conectar a um nó
    private void connectNode() {
        String noInfo = JOptionPane.showInputDialog("Insira o endereço e a porta do nó (formato IP:Porta)");
        if (noInfo != null && noInfo.contains(":")) {
            String[] parts = noInfo.split(":");
            String newIp = parts[0];
            int newPort = Integer.parseInt(parts[1]);

            // Iniciar uma nova thread para conectar ao nó especificado
            new Thread(() -> {
                try (Socket socket = new Socket(newIp, newPort);
                        ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
                        ObjectInputStream in = new ObjectInputStream(socket.getInputStream())) {

                    // Enviar pedido de conexão
                    String newAddress = this.ipAddress + ":" + this.port;
                    out.writeObject("CONNECT " + newAddress);
                    out.flush();
                    System.out.println("Pedido de conexão enviado para " + newIp + ":" + newPort);

                    // Receber a resposta do nó conectado
                    String response = (String) in.readObject();
                    System.out.println("Resposta do nó conectado: " + response);

                    // Verificar se a conexão foi bem sucedida
                    if (!response.contains("CONNECTED")) {
                        System.err.println("Erro ao conectar ao nó: " + response);
                        return;
                    }

                    // Adicionar o nó conectado à lista de vizinhos
                    addNeighbor(newIp + ":" + newPort);

                    // Mostrar pop-up de sucesso
                    SwingUtilities.invokeLater(() -> JOptionPane.showMessageDialog(null,
                            "Conectado com sucesso ao nó " + newIp + ":" + newPort,
                            "Conexão Estabelecida",
                            JOptionPane.INFORMATION_MESSAGE));
                } catch (IOException | ClassNotFoundException e) {
                    System.err.println("Erro ao conectar ao nó: " + e.getMessage());
                }
            }).start();
        } else {
            JOptionPane.showMessageDialog(null, "Formato inválido. Use: IP:Porta");
        }
    }

    // Download de um ficheiro
    private void downloadFile(String fileName) {
        new Thread(() -> {
            int dataIndex = 0;
            boolean fileComplete = false;
    
            try (FileOutputStream downloadedFile = new FileOutputStream(new File(fileDirectory, fileName))) {
                while (!fileComplete) {
                    try (Socket socket = new Socket(ipAddress, port);
                         ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream());
                         ObjectInputStream in = new ObjectInputStream(socket.getInputStream())) {
    
                        FileRequest request = new FileRequest(fileName, dataIndex);
                        out.writeObject(request);
                        out.flush();
    
                        Object response = in.readObject();
                        if (response instanceof FileResponse) {
                            FileResponse fileResponse = (FileResponse) response;
                            byte[] fileData = fileResponse.getFileData();
    
                            if (fileData.length == 0) {
                                System.out.println("Fim do ficheiro detectado no cliente.");
                                fileComplete = true;
                                continue;
                            }
    
                            downloadedFile.write(fileData);
                            System.out.println("Bloco recebido para " + fileName + " (índice: " + dataIndex + "): " 
                                    + new String(fileData).trim());
                            dataIndex++;
                        } else {
                            throw new IOException("Resposta inesperada do servidor.");
                        }
                    }
                }
                JOptionPane.showMessageDialog(null, "Ficheiro descarregado com sucesso: " + fileName);
            } catch (Exception e) {
                e.printStackTrace();
                JOptionPane.showMessageDialog(null, "Erro ao descarregar o ficheiro: " + e.getMessage());
            }
        }).start();
    }
    
    

}
import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class NodeServer {
    // Atributos
    private int port;
    private final String ipAddress = "127.0.0.1";
    private ServerSocket serverSocket;
    private String fileDirectory;
    private IscTorrentNode node;

    public NodeServer(int port, String fileDirectory, IscTorrentNode node) {
        this.port = port;
        this.fileDirectory = fileDirectory;
        this.node = node;
    }

    public void startServer() {
        try {
            serverSocket = new ServerSocket(port, 50, InetAddress.getByName(ipAddress));
            System.out.println("Servidor iniciado na porta " + port);
            
            // Thread que aceita conexões de clientes
            // Cria uma nova thread para lidar com cada cliente conectado
            new Thread(() -> {
                while (!serverSocket.isClosed()) {
                    try {
                        Socket clientSocket = serverSocket.accept();
                        System.out.println("Novo nó conectado: " + clientSocket.getLocalSocketAddress());

                        // Passa o socket e a pasta ao ClientHandler, que vai lidar com as mensagens do cliente
                        // ClientHandler lida com pedidos de SEARCH, DOWNLOAD e CONNECT
                        new Thread(new ClientHandler(clientSocket, fileDirectory, node)).start();
                    } catch (IOException e) {
                        if (!serverSocket.isClosed())
                            System.err.println("Erro ao aceitar conexão: " + e.getMessage());
                    }
                }
            }).start();
        } catch (IOException e) {
            System.err.println("Erro ao iniciar o servidor: " + e.getMessage());
        }
    }

    public void stopServer() {
        try {
            serverSocket.close();
            System.out.println("Servidor encerrado.");
        } catch (IOException e) {
            System.err.println("Erro ao encerrar o servidor: " + e.getMessage());
        }
    }
}
import java.io.Serializable;

public class SearchRequest implements Serializable {
    private static final long serialVersionUID = 1L; // Evita problemas de versão
    private String searchTerm;

    public SearchRequest(String searchTerm) {
        this.searchTerm = searchTerm;
    }

    public String getSearchTerm() {
        return searchTerm;
    }
}
import java.io.Serializable;
import java.util.List;

public class SearchResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private List<String> fileNames;

    public SearchResponse(List<String> fileNames) {
        this.fileNames = fileNames;
    }

    public List<String> getFileNames() {
        return fileNames;
    }
}
